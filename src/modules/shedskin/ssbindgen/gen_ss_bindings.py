'''
This utility fully automates[1] the generation of ShedSkin bindings for a C library described by a JSON metadata file. Currently 
this is intended for generating bindings for Raylib's C APIs.

One can run this Python file to execute the entire binding generation and install process, or run each step individually 
(by executing the Python file for each step instead) so that if the process fails one can resume quickly.

This is done in steps mostly due to the fact that Raylib being a large enough API - and Shedskin takes time to crunch through all 
the inferencing.  So when developing on these bindings a faster process is needed to iterate code quickly.  If the entire
inference/gen/compile process happened for every code change development iteration would be too slow here.

See more comments below for details on each step.

[1] Note, the process here is simply automating steps described in Shedskin's docs under 'Calling C/C++ code'. Really 
I just took the manual process there and automated all the steps to ease keeping bindings in sync as Raylib's API evolves. 
Recommended to read this doc first (it's very short/simple) to understand why this script does what it does. 

See the documention for writing ShedSkin bindings here:
https://shedskin.readthedocs.io/en/latest/documentation.html#calling-c-c-code

'''

# Step 1: Raylib C API has a parser utility that generates JSON from the API for ease of binding work. We assume
# This JSON file already exists, we first load it and generate python code corresponding to the API.  If this file
# does not exist it can be generated with the reapyr/src/modules/cpython/tools/header2json/header2json.py utility
# in this repo.
print ("Step 1: Generating raylib.py from JSON files in this repo....")
import step1_json2py
step1_json2py.gen_ss_py()

# Step 2: We take the Python file generated, send it to Shedskin to generate C++ code.
# This gives us a 'skeleton' of code for a Shedskin module to insert actual binding logic that invokes Raylib.
# Note, this Python code contains lots of superfluous 'todo_*' type symbols so that step3 can find and swap in 
# implementation code.  It's pretty ugly at this step due to these markers, but still valid Python so SS can
# generate a C++ module ready to be modified.
print ("Step 2: Invoking Shedskin on raylib.py to generate stub C++ code...")
import step2_py2cpp
step2_py2cpp.py2cpp()

# Step 3: The C++ code output by Shedskin is loaded and modified to 'inject' C++ logic to invoke Raylib's APIs
# The script will look for various 'todo_*' type markers generated by Step1/2 and swap with C++ code. It will 
# also (hopefully) remove any remaining temporary markers so the C++ code is more debuggable / readable.
print ("Step 3: Modifying C++ files with logic to invoke Raylib APIs...")
import step3_modify_cpp
step3_modify_cpp.modify_ss_cpp()

# Step 4: Here we call 'make' on the Makefile that Shedskin generates and test that the module actually works.
# if not we want to tell the user and abort this script so issues can be corrected.
print ("Step 4: Invoking make and testing the generated Shedskin bindings...")
import step4_build_test
step4_build_test.build_and_test()

# Step 5: Once output is verified successfully in step 4, we install the Shedskin raylib module.
# 'Installation' here means copying the generated C++ and Python code to a lib folder, so that the
# module can be found by Shedskin in the future - and thereby usable by SS to compile Raylib Python apps to native code.
print ("Step 5: Installing Shedskin bindings to lib folder...")
import step5_install
step5_install.install_ss_bindings()

print (f"Shedskin bindings have been generated and installed!")